/*
Примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: 
увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся.
Служит для построения более сложных механизмов синхронизации и используется для синхронизации параллельно работающих задач,
для защиты передачи данных через разделяемую память, для защиты критических секций, а также для управления доступом к аппаратному обеспечению.

РАБОТАЕТ С КРИТИЧЕСКИМ РЕСУРСОМ
*/

#include <iostream>
#include <windows.h>
using namespace std;

int m[25]; // глобальный массив для вывода на экран

HANDLE semaphore;

// функция потока
DWORD WINAPI ThreadFunc(LPVOID lpParam)
{
    WaitForSingleObject(semaphore, INFINITE);
    for (int i = 0; i < 25; i++)
        cout << m[i] << " "; // поэлементный вывод массива на экран
    cout << endl;
    ReleaseSemaphore(semaphore, 1, 0);      //Дескриптор объекта семафора.
                                            //Сумма, на которую необходимо увеличить текущее число объектов семафора. Это значение должно быть больше нуля. Если указанное значение приведет к превышению максимального числа семафора, указанного при создании семафора, счетчик не изменяется и функция возвращает значение FALSE.
                                            //Указатель на переменную для получения предыдущего числа для семафора.
    return 0;
}

int main()
{
    semaphore = CreateSemaphore(NULL, 1, 1, L"same name");   //указывает начальное число семафора. При каждом освобождении потока ожидания из-за сигнального состояния семафора количество семафора уменьшается на один.
    SetConsoleOutputCP(1251);
    cout << "Вывод двух возрастающих последовательностей:"
        << endl;
    for (int i = 0; i < 25; m[i++] = i);   // массив заполняется рядом чисел

    HANDLE Th;          // дескриптор потока
// Создаем дополнительный поток и начинаем печатать последовательность
    Th = CreateThread(NULL, 0, ThreadFunc, NULL, 0, NULL);

    WaitForSingleObject(semaphore, INFINITE);
    for (int i = 0; i < 25; i++)
        cout << m[i] << " ";
    cout << endl;
    ReleaseSemaphore(semaphore, 1, 0);
    // дожидаемся завершения другого потока
    // результат WaitForSingleObject не важен
    WaitForSingleObject(Th, INFINITE);
    CloseHandle(semaphore);
    system("pause");
    return 0;
}